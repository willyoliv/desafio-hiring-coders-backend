{"version":3,"file":"splunk-events.min.js","sources":["../src/debounceStrategy.ts","../src/debounce.ts","../src/exponentialBackoffStrategy.ts","../src/request.ts","../src/splunk-events.ts"],"sourcesContent":["import type { SplunkEvent, Strategy } from './strategy'\nimport type { DebouncedFn } from './debounce'\nimport debounce from './debounce'\n\nconst DEFAULT_DEBOUNCE_TIME = 2_000\n\nexport class DebounceStrategy implements Strategy {\n  private pendingEvents: SplunkEvent[] = []\n  private events: SplunkEvent[] = []\n\n  private isSendingEvents = false\n  private flushPending = false\n\n  private autoRetryFlush: boolean\n  private sendEvents: (events: SplunkEvent[]) => Promise<void>\n\n  public flushEvents: DebouncedFn\n\n  constructor({\n    debounceTime = DEFAULT_DEBOUNCE_TIME,\n    autoRetryFlush,\n    sendEvents,\n  }: {\n    debounceTime?: number\n    autoRetryFlush: boolean\n    sendEvents: (events: SplunkEvent[]) => Promise<void>\n  }) {\n    this.flushEvents = debounce(this.flushImpl, debounceTime)\n    this.autoRetryFlush = autoRetryFlush\n    this.sendEvents = sendEvents\n  }\n\n  public abort() {\n    this.flushEvents.clear()\n  }\n\n  public addEvent(event: SplunkEvent) {\n    this.events.push(event)\n  }\n\n  private flushImpl = () => {\n    if (this.isSendingEvents) {\n      this.flushPending = true\n\n      return\n    }\n\n    this.pendingEvents = Array.from(this.events)\n    this.events = []\n    this.isSendingEvents = true\n\n    this.sendEvents(this.pendingEvents)\n      .then(() => {\n        this.pendingEvents = []\n        this.isSendingEvents = false\n\n        if (!this.flushPending) {\n          return\n        }\n\n        this.flushPending = false\n\n        return this.flushImpl()\n      })\n      .catch(() => {\n        this.events = this.events.concat(this.pendingEvents)\n        this.pendingEvents = []\n        this.isSendingEvents = false\n\n        if (this.autoRetryFlush) {\n          this.flushEvents()\n        }\n      })\n  }\n}\n","export interface DebouncedFn {\n  (): void\n  clear(): void\n}\n\nexport default function debounce<T>(\n  func: (...args: T[]) => void | Promise<void>,\n  wait = 100\n): DebouncedFn {\n  let timeout: NodeJS.Timeout | null = null\n  let cancel: (() => void) | null = null\n\n  const debounced = (...args: T[]) => {\n    if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    return new Promise<void>((res, rej) => {\n      cancel = rej\n\n      timeout = setTimeout(() => {\n        const maybePromise = func(...args)\n\n        if (maybePromise != null) {\n          maybePromise.then(res).catch(rej)\n        }\n      }, wait)\n    })\n  }\n\n  debounced.clear = () => {\n    if (!timeout) {\n      return\n    }\n\n    clearTimeout(timeout)\n    cancel?.()\n\n    timeout = null\n  }\n\n  return debounced\n}\n","import type { Strategy, SplunkEvent } from './strategy'\n\nconst DEFAULT_EXPONENTIAL_BACKOFF_LIMIT = 60_000\n\nexport class ExponentialBackoffStrategy implements Strategy {\n  private isBackoffInProgress = false\n  private maxNumberOfRetries = Infinity\n\n  private events: SplunkEvent[] = []\n  private pendingEvents: SplunkEvent[] = []\n  private exponentialBackoffLimit: number\n\n  private sendEvents: (events: SplunkEvent[]) => Promise<void>\n\n  constructor({\n    sendEvents,\n    exponentialBackoffLimit = DEFAULT_EXPONENTIAL_BACKOFF_LIMIT,\n    maxNumberOfRetries,\n  }: {\n    sendEvents: (events: SplunkEvent[]) => Promise<void>\n    exponentialBackoffLimit?: number\n    maxNumberOfRetries?: number\n  }) {\n    this.sendEvents = sendEvents\n    this.exponentialBackoffLimit = exponentialBackoffLimit\n    this.maxNumberOfRetries = maxNumberOfRetries ?? this.maxNumberOfRetries\n  }\n\n  public addEvent(event: SplunkEvent) {\n    this.events.push(event)\n  }\n\n  public flushEvents(): Promise<void> {\n    if (this.isBackoffInProgress) {\n      return Promise.resolve()\n    }\n\n    this.isBackoffInProgress = true\n\n    const backoffMultiplier = 2\n\n    const executeFlush = (depth = 0): Promise<void> => {\n      this.pendingEvents = this.pendingEvents.concat(this.events)\n\n      this.events = []\n\n      return this.sendEvents(this.pendingEvents)\n        .then(() => {\n          this.pendingEvents = []\n          this.isBackoffInProgress = false\n\n          if (this.events.length > 0) {\n            return this.flushEvents()\n          }\n\n          return Promise.resolve()\n        })\n        .catch(() => {\n          const waitTime = backoffMultiplier ** depth * 1_000\n\n          if (depth > this.maxNumberOfRetries) {\n            this.events = []\n            this.isBackoffInProgress = false\n\n            return\n          }\n\n          return new Promise((resolve, reject) => {\n            setTimeout(() => {\n              executeFlush(depth + 1)\n                .then(resolve, reject)\n                .catch(reject)\n            }, Math.min(waitTime, this.exponentialBackoffLimit))\n          })\n        })\n    }\n\n    return executeFlush()\n  }\n}\n","export interface FetchContext extends Omit<RequestInit, 'body'> {\n  url: string\n  data: BodyInit\n  responseType: string\n}\n\nexport function fetchRequest(context: FetchContext) {\n  if (\n    (typeof window !== 'undefined' && typeof window.fetch !== 'function') ||\n    (typeof global !== 'undefined' &&\n      typeof (global as any).fetch !== 'function')\n  ) {\n    console.log('Error, using fetchRequest without fetch object')\n\n    return Promise.resolve(null)\n  }\n\n  return fetch(context.url, {\n    ...context,\n    body: context.data,\n  }).then((response) => {\n    if (context.responseType === 'json') {\n      return response.json()\n    }\n\n    return response\n  })\n}\n","import { DebounceStrategy } from './debounceStrategy'\nimport { ExponentialBackoffStrategy } from './exponentialBackoffStrategy'\nimport { FetchContext, fetchRequest } from './request'\nimport type { EventData, SplunkEvent, Strategy } from './strategy'\n\nexport { FetchContext }\n\nexport interface Config {\n  /**\n   * Whether or not to automatically flush batched events\n   * after calling {@link SplunkEvent#logEvent}.\n   *\n   * Turned on by default. This option will also be turned\n   * on when using `useExponentialBackoff`, regardless of the\n   * value passed the the configuration.\n   */\n  autoFlush?: boolean\n  /**\n   * Whether or not to automatically retry failed flushes.\n   */\n  autoRetryFlush?: boolean\n  /**\n   * Timeout, in milliseconds, used to batch events together in one single request.\n   */\n  debounceTime?: number\n  /**\n   * Wether or not to enable debugging of the {@link SplunkEvent} class\n   * itself.\n   */\n  debug?: boolean\n  /**\n   * Endpoint of your Splunk server.\n   */\n  endpoint: string\n  /**\n   * Host of your Splunk server.\n   */\n  host?: string\n  /**\n   * Whether or not to inject additional information about the user's\n   * device and browser in the Splunk event.\n   */\n  injectAdditionalInfo?: boolean\n  /**\n   * @deprecated Use `injectAdditionalInfo` instead\n   */\n  injectAditionalInfo?: boolean\n  /**\n   * Whether or not to automatically add the timestamp to the Splunk event.\n   */\n  injectTimestamp?: boolean\n  /**\n   * Path of the Splunk server endpoint.\n   */\n  path?: string\n  /**\n   * Custom request function to use in environments where {@link window.fetch}\n   * is not available.\n   */\n  request?: (fetchContext: FetchContext) => Promise<Response>\n  /**\n   * Whether or not to parse the event data in {@link SplunkEvent#logEvent}.\n   */\n  shouldParseEventData?: boolean\n  /**\n   * Source of the Splunk event.\n   */\n  source?: string\n  /**\n   * Token used to authenticate with the Splunk server.\n   */\n  token: string\n  /**\n   * Custom headers to be added in the request\n   */\n  headers?: HeadersInit\n  /**\n   * Configures the {@link SplunkEvent#flush} method to use an\n   * exponential backoff algorithm instead of a fixed debounce time.\n   *\n   * Turned off by default.\n   */\n  useExponentialBackoff?: boolean\n  /**\n   * Maximum time, in milliseconds, to use for the exponential backoff\n   * algorithm.\n   *\n   * The default limit is 60_000 milliseconds.\n   */\n  exponentialBackoffLimit?: number\n  /**\n   * Maximum number of retries of failed requests before dropping the events.\n   */\n  maxNumberOfRetries?: number\n}\n\nconst DEFAULT_USE_EXPONENTIAL_BACKOFF = false\n\nexport default class SplunkEvents {\n  private _requestImpl: (\n    fetchContext: FetchContext\n  ) => Promise<Response | null> = fetchRequest\n\n  private autoFlush = true\n  private debug = false\n  private endpoint?: string\n  private headers?: HeadersInit\n  private host = '-'\n  private injectAdditionalInfo = false\n  private injectTimestamp = false\n  private path = '/services/collector/event'\n  private shouldParseEventData = true\n  private source = 'log'\n  private token?: string\n\n  private configured = false\n\n  private flushStrategy: Strategy | null = null\n\n  constructor(config?: Config) {\n    if (!config) {\n      return\n    }\n\n    this.config(config)\n  }\n\n  /**\n   * Configure this Splunk Event instance.\n   */\n  public config(config: Partial<Config>) {\n    if (this.configured) {\n      return\n    }\n\n    this.configured = true\n\n    this.endpoint = config?.endpoint ?? this.endpoint // required\n    this.token = config?.token ?? this.endpoint // required\n    this.injectAdditionalInfo =\n      config?.injectAditionalInfo ??\n      config?.injectAdditionalInfo ??\n      this.injectAdditionalInfo\n\n    this.autoFlush = config?.autoFlush ?? this.autoFlush\n\n    this.source = config?.source ?? this.source\n    this.path = config?.path ?? this.path\n    this.host = config?.host ?? this.host\n    this.debug = config?.debug ?? this.debug\n\n    this._requestImpl = config?.request ?? this._requestImpl\n\n    this.injectTimestamp = config?.injectTimestamp ?? this.injectTimestamp\n    this.shouldParseEventData =\n      config?.shouldParseEventData ?? this.shouldParseEventData\n\n    this.headers = {\n      Authorization: `Splunk ${this.token}`,\n      'Content-Type': 'application/json',\n      ...(config?.headers ?? {}),\n    }\n\n    const useExponentialBackoff =\n      config?.useExponentialBackoff ?? DEFAULT_USE_EXPONENTIAL_BACKOFF\n\n    // Exponential backoff configurations\n    const exponentialBackoffLimit = config?.exponentialBackoffLimit\n    const maxNumberOfRetries = config?.maxNumberOfRetries\n\n    // Debounce configurations\n    const debounceTime = config?.debounceTime\n    const autoRetryFlush = config?.autoRetryFlush ?? true\n\n    if (useExponentialBackoff) {\n      this.autoFlush = true\n\n      this.flushStrategy = new ExponentialBackoffStrategy({\n        sendEvents: this.flush,\n        exponentialBackoffLimit,\n        maxNumberOfRetries,\n      })\n    } else {\n      this.flushStrategy = new DebounceStrategy({\n        sendEvents: this.flush,\n        debounceTime,\n        autoRetryFlush,\n      })\n    }\n  }\n\n  /**\n   * Logs an event to Splunk.\n   *\n   * This method will send the data to the Splunk endpoint configured\n   * in the {@link SplunkEvent#config} method. For now, you can only\n   * send primitive types such as string, numbers and booleans in the\n   * event data object.\n   *\n   * @argument level Level of criticity of this log, use values such as\n   * \"Critical\", \"Important\" or \"Debug\"\n   * @argument type Type of this log, use values such as \"Error\", \"Warn\"\n   * or \"Info\"\n   * @argument workflowType Type of this \"workflow\", you can use something\n   * related to your application domain, such as \"checkout\" for events happening\n   * in the Checkout page.\n   * @argument workflowInstance A more fine-grained level of information\n   * regarding the workflow, use values such as \"checkout-cart\" for events\n   * that happened in the Cart page of Checkout for example.\n   * @argument eventData Any custom event data you may find useful to log\n   * together that can provide more information.\n   * @argument account In multi-tenant environment it can be useful to know\n   * the exact account this event is happening in.\n   */\n  public logEvent = (\n    level: string,\n    type: string,\n    workflowType: string,\n    workflowInstance: string,\n    eventData?: EventData | null,\n    account = ''\n  ) => {\n    if (this.flushStrategy == null) {\n      throw new Error('SplunkEvents instance is not configured properly')\n    }\n\n    this.validateEvent(eventData)\n\n    const eventObj = {\n      level,\n      type,\n      workflowType,\n      workflowInstance,\n      account,\n      ...eventData,\n      ...(this.injectAdditionalInfo ? this.getAdditionalInfo() : {}),\n    }\n\n    const event = this.shouldParseEventData\n      ? this.parseEventData(eventObj)\n      : eventObj\n\n    const data = {\n      sourcetype: this.source,\n      host: this.host,\n      ...(this.injectTimestamp && { time: +new Date() }),\n      event,\n    }\n\n    this.flushStrategy.addEvent(data)\n\n    if (this.autoFlush) {\n      this.flushStrategy.flushEvents()\n    }\n  }\n\n  /**\n   * Exposes the implementation for the request function\n   * used to send the events to the Splunk API.\n   */\n  public request(fetchContext: FetchContext) {\n    return this._requestImpl(fetchContext)\n  }\n\n  private parseEventData(event: EventData) {\n    let parsedEvent = ''\n\n    for (const key in event) {\n      if (\n        Object.prototype.hasOwnProperty.call(event, key) &&\n        event[key] != null\n      ) {\n        const value = event[key]\n\n        switch (typeof value) {\n          case 'string':\n            parsedEvent += `${key}=\"${value.replace(/\"/g, '')}\" `\n            break\n\n          case 'boolean':\n\n          // eslint-disable-next-line no-fallthrough\n          case 'number':\n            parsedEvent += `${key}=${value} `\n            break\n\n          default:\n            throw new Error('Event property must be string, number or boolean')\n        }\n      }\n    }\n\n    return parsedEvent\n  }\n\n  private validateEvent(event?: EventData | null): asserts event is EventData {\n    if (event === null) {\n      throw new Error('Event must not be null')\n    }\n\n    if (event === undefined) {\n      throw new Error('Event must not be undefined')\n    }\n\n    if (typeof event !== 'object') {\n      throw new Error('Event must be an object')\n    }\n  }\n\n  public getAdditionalInfo() {\n    if (typeof navigator === 'undefined' || typeof window === 'undefined') {\n      return ''\n    }\n\n    const { screen, location } = window\n\n    const additionalInfo =\n      `${navigator.userAgent.replace(/,/g, ';')},` +\n      `${(navigator as any).browserLanguage || navigator.language},` +\n      `${navigator.platform},${screen.availWidth || '-'},${\n        screen.availHeight || '-'\n      },${location.hostname},` +\n      `${location.pathname},${location.protocol.replace(':', '')},${\n        location.hash || '-'\n      }`\n\n    return {\n      additional_info: additionalInfo,\n    }\n  }\n\n  /**\n   * Flushes pending events into one single request.\n   *\n   * You won't need to use this function unless you configured\n   * this instance to not auto flush the events.\n   */\n  public flush = async (events?: SplunkEvent[]): Promise<void> => {\n    this.validateConfig()\n\n    if (!events) {\n      this.flushStrategy!.flushEvents()\n\n      return\n    }\n\n    if (events.length === 0) {\n      return\n    }\n\n    if (this.debug) {\n      console.log(`sending ${events.length} events to splunk`)\n    }\n\n    const splunkBatchedFormattedEvents = this.formatEventsForSplunkBatch(events)\n\n    return this.request({\n      url: `${this.endpoint}${this.path}`,\n      method: 'POST',\n      data: splunkBatchedFormattedEvents,\n      headers: this.headers ?? {},\n      responseType: 'json',\n    })\n      .then(() => {\n        if (this.debug) {\n          console.log(`${events.length} events successfuly sent to splunk`)\n        }\n      })\n      .catch((e) => {\n        if (this.debug) {\n          console.warn('Error sending events to splunk.', e)\n        }\n\n        throw e\n      })\n  }\n\n  private formatEventsForSplunkBatch(events: SplunkEvent[]) {\n    return events.map((event) => JSON.stringify(event)).join('\\n')\n  }\n\n  private validateConfig() {\n    if (this.token == null) {\n      throw new Error('Token must not be null nor undefined')\n    }\n\n    if (this.endpoint == null) {\n      throw new Error('Endpoint must not be null nor undefined')\n    }\n\n    if (this.flushStrategy == null) {\n      throw new Error(\n        'Instance must be configured (either by constructor or calling config method) before flushing events'\n      )\n    }\n  }\n}\n"],"names":["_a","_b","debounceTime","autoRetryFlush","sendEvents","this","_this","isSendingEvents","flushPending","pendingEvents","Array","from","events","then","flushImpl","concat","flushEvents","func","wait","timeout","cancel","debounced","_i","args","clearTimeout","Promise","res","rej","setTimeout","maybePromise","clear","debounce","DebounceStrategy","event","push","exponentialBackoffLimit","maxNumberOfRetries","Infinity","ExponentialBackoffStrategy","isBackoffInProgress","resolve","executeFlush","depth","length","waitTime","Math","reject","min","fetchRequest","context","window","fetch","global","console","log","url","body","data","response","responseType","json","config","level","type","workflowType","workflowInstance","eventData","account","flushStrategy","Error","validateEvent","eventObj","injectAdditionalInfo","getAdditionalInfo","shouldParseEventData","parseEventData","sourcetype","source","host","injectTimestamp","time","Date","addEvent","autoFlush","validateConfig","debug","splunkBatchedFormattedEvents","formatEventsForSplunkBatch","request","endpoint","path","method","headers","e","warn","SplunkEvents","configured","token","injectAditionalInfo","_requestImpl","Authorization","Content-Type","useExponentialBackoff","flush","fetchContext","parsedEvent","key","Object","prototype","hasOwnProperty","call","value","replace","undefined","navigator","screen","location","additional_info","userAgent","browserLanguage","language","platform","availWidth","availHeight","hostname","pathname","protocol","hash","map","JSON","stringify","join"],"mappings":"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"}