/*!
 * splunk-events v1.7.0
 * Copyright (c) VTEX
 * Released under the MIT License.
 */
'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function debounce(func, wait) {
    if (wait === void 0) { wait = 100; }
    var timeout = null;
    var cancel = null;
    var debounced = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        return new Promise(function (res, rej) {
            cancel = rej;
            timeout = setTimeout(function () {
                var maybePromise = func.apply(void 0, args);
                if (maybePromise != null) {
                    maybePromise.then(res)["catch"](rej);
                }
            }, wait);
        });
    };
    debounced.clear = function () {
        if (!timeout) {
            return;
        }
        clearTimeout(timeout);
        cancel === null || cancel === void 0 ? void 0 : cancel();
        timeout = null;
    };
    return debounced;
}

var DEFAULT_DEBOUNCE_TIME = 2000;
var DebounceStrategy = /** @class */ (function () {
    function DebounceStrategy(_a) {
        var _this = this;
        var _b = _a.debounceTime, debounceTime = _b === void 0 ? DEFAULT_DEBOUNCE_TIME : _b, autoRetryFlush = _a.autoRetryFlush, sendEvents = _a.sendEvents;
        this.pendingEvents = [];
        this.events = [];
        this.isSendingEvents = false;
        this.flushPending = false;
        this.flushImpl = function () {
            if (_this.isSendingEvents) {
                _this.flushPending = true;
                return;
            }
            _this.pendingEvents = Array.from(_this.events);
            _this.events = [];
            _this.isSendingEvents = true;
            _this.sendEvents(_this.pendingEvents)
                .then(function () {
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
                if (!_this.flushPending) {
                    return;
                }
                _this.flushPending = false;
                return _this.flushImpl();
            })["catch"](function () {
                _this.events = _this.events.concat(_this.pendingEvents);
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
                if (_this.autoRetryFlush) {
                    _this.flushEvents();
                }
            });
        };
        this.flushEvents = debounce(this.flushImpl, debounceTime);
        this.autoRetryFlush = autoRetryFlush;
        this.sendEvents = sendEvents;
    }
    DebounceStrategy.prototype.abort = function () {
        this.flushEvents.clear();
    };
    DebounceStrategy.prototype.addEvent = function (event) {
        this.events.push(event);
    };
    return DebounceStrategy;
}());

var DEFAULT_EXPONENTIAL_BACKOFF_LIMIT = 60000;
var ExponentialBackoffStrategy = /** @class */ (function () {
    function ExponentialBackoffStrategy(_a) {
        var sendEvents = _a.sendEvents, _b = _a.exponentialBackoffLimit, exponentialBackoffLimit = _b === void 0 ? DEFAULT_EXPONENTIAL_BACKOFF_LIMIT : _b, maxNumberOfRetries = _a.maxNumberOfRetries;
        this.isBackoffInProgress = false;
        this.maxNumberOfRetries = Infinity;
        this.events = [];
        this.pendingEvents = [];
        this.sendEvents = sendEvents;
        this.exponentialBackoffLimit = exponentialBackoffLimit;
        this.maxNumberOfRetries = maxNumberOfRetries !== null && maxNumberOfRetries !== void 0 ? maxNumberOfRetries : this.maxNumberOfRetries;
    }
    ExponentialBackoffStrategy.prototype.addEvent = function (event) {
        this.events.push(event);
    };
    ExponentialBackoffStrategy.prototype.flushEvents = function () {
        var _this = this;
        if (this.isBackoffInProgress) {
            return Promise.resolve();
        }
        this.isBackoffInProgress = true;
        var backoffMultiplier = 2;
        var executeFlush = function (depth) {
            if (depth === void 0) { depth = 0; }
            _this.pendingEvents = _this.pendingEvents.concat(_this.events);
            _this.events = [];
            return _this.sendEvents(_this.pendingEvents)
                .then(function () {
                _this.pendingEvents = [];
                _this.isBackoffInProgress = false;
                if (_this.events.length > 0) {
                    return _this.flushEvents();
                }
                return Promise.resolve();
            })["catch"](function () {
                var waitTime = Math.pow(backoffMultiplier, depth) * 1000;
                if (depth > _this.maxNumberOfRetries) {
                    _this.events = [];
                    _this.isBackoffInProgress = false;
                    return;
                }
                return new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        executeFlush(depth + 1)
                            .then(resolve, reject)["catch"](reject);
                    }, Math.min(waitTime, _this.exponentialBackoffLimit));
                });
            });
        };
        return executeFlush();
    };
    return ExponentialBackoffStrategy;
}());

function fetchRequest(context) {
    if ((typeof window !== 'undefined' && typeof window.fetch !== 'function') ||
        (typeof global !== 'undefined' &&
            typeof global.fetch !== 'function')) {
        console.log('Error, using fetchRequest without fetch object');
        return Promise.resolve(null);
    }
    return fetch(context.url, __assign(__assign({}, context), { body: context.data })).then(function (response) {
        if (context.responseType === 'json') {
            return response.json();
        }
        return response;
    });
}

var DEFAULT_USE_EXPONENTIAL_BACKOFF = false;
var SplunkEvents = /** @class */ (function () {
    function SplunkEvents(config) {
        var _this = this;
        this._requestImpl = fetchRequest;
        this.autoFlush = true;
        this.debug = false;
        this.host = '-';
        this.injectAdditionalInfo = false;
        this.injectTimestamp = false;
        this.path = '/services/collector/event';
        this.shouldParseEventData = true;
        this.source = 'log';
        this.configured = false;
        this.flushStrategy = null;
        /**
         * Logs an event to Splunk.
         *
         * This method will send the data to the Splunk endpoint configured
         * in the {@link SplunkEvent#config} method. For now, you can only
         * send primitive types such as string, numbers and booleans in the
         * event data object.
         *
         * @argument level Level of criticity of this log, use values such as
         * "Critical", "Important" or "Debug"
         * @argument type Type of this log, use values such as "Error", "Warn"
         * or "Info"
         * @argument workflowType Type of this "workflow", you can use something
         * related to your application domain, such as "checkout" for events happening
         * in the Checkout page.
         * @argument workflowInstance A more fine-grained level of information
         * regarding the workflow, use values such as "checkout-cart" for events
         * that happened in the Cart page of Checkout for example.
         * @argument eventData Any custom event data you may find useful to log
         * together that can provide more information.
         * @argument account In multi-tenant environment it can be useful to know
         * the exact account this event is happening in.
         */
        this.logEvent = function (level, type, workflowType, workflowInstance, eventData, account) {
            if (account === void 0) { account = ''; }
            if (_this.flushStrategy == null) {
                throw new Error('SplunkEvents instance is not configured properly');
            }
            _this.validateEvent(eventData);
            var eventObj = __assign(__assign({ level: level,
                type: type,
                workflowType: workflowType,
                workflowInstance: workflowInstance,
                account: account }, eventData), (_this.injectAdditionalInfo ? _this.getAdditionalInfo() : {}));
            var event = _this.shouldParseEventData
                ? _this.parseEventData(eventObj)
                : eventObj;
            var data = __assign(__assign({ sourcetype: _this.source, host: _this.host }, (_this.injectTimestamp && { time: +new Date() })), { event: event });
            _this.flushStrategy.addEvent(data);
            if (_this.autoFlush) {
                _this.flushStrategy.flushEvents();
            }
        };
        /**
         * Flushes pending events into one single request.
         *
         * You won't need to use this function unless you configured
         * this instance to not auto flush the events.
         */
        this.flush = function (events) { return __awaiter(_this, void 0, void 0, function () {
            var splunkBatchedFormattedEvents;
            var _this = this;
            var _a;
            return __generator(this, function (_b) {
                this.validateConfig();
                if (!events) {
                    this.flushStrategy.flushEvents();
                    return [2 /*return*/];
                }
                if (events.length === 0) {
                    return [2 /*return*/];
                }
                if (this.debug) {
                    console.log("sending " + events.length + " events to splunk");
                }
                splunkBatchedFormattedEvents = this.formatEventsForSplunkBatch(events);
                return [2 /*return*/, this.request({
                        url: "" + this.endpoint + this.path,
                        method: 'POST',
                        data: splunkBatchedFormattedEvents,
                        headers: (_a = this.headers) !== null && _a !== void 0 ? _a : {},
                        responseType: 'json',
                    })
                        .then(function () {
                        if (_this.debug) {
                            console.log(events.length + " events successfuly sent to splunk");
                        }
                    })["catch"](function (e) {
                        if (_this.debug) {
                            console.warn('Error sending events to splunk.', e);
                        }
                        throw e;
                    })];
            });
        }); };
        if (!config) {
            return;
        }
        this.config(config);
    }
    /**
     * Configure this Splunk Event instance.
     */
    SplunkEvents.prototype.config = function (config) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (this.configured) {
            return;
        }
        this.configured = true;
        this.endpoint = (_a = config === null || config === void 0 ? void 0 : config.endpoint) !== null && _a !== void 0 ? _a : this.endpoint; // required
        this.token = (_b = config === null || config === void 0 ? void 0 : config.token) !== null && _b !== void 0 ? _b : this.endpoint; // required
        this.injectAdditionalInfo =
            (_d = (_c = config === null || config === void 0 ? void 0 : config.injectAditionalInfo) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.injectAdditionalInfo) !== null && _d !== void 0 ? _d : this.injectAdditionalInfo;
        this.autoFlush = (_e = config === null || config === void 0 ? void 0 : config.autoFlush) !== null && _e !== void 0 ? _e : this.autoFlush;
        this.source = (_f = config === null || config === void 0 ? void 0 : config.source) !== null && _f !== void 0 ? _f : this.source;
        this.path = (_g = config === null || config === void 0 ? void 0 : config.path) !== null && _g !== void 0 ? _g : this.path;
        this.host = (_h = config === null || config === void 0 ? void 0 : config.host) !== null && _h !== void 0 ? _h : this.host;
        this.debug = (_j = config === null || config === void 0 ? void 0 : config.debug) !== null && _j !== void 0 ? _j : this.debug;
        this._requestImpl = (_k = config === null || config === void 0 ? void 0 : config.request) !== null && _k !== void 0 ? _k : this._requestImpl;
        this.injectTimestamp = (_l = config === null || config === void 0 ? void 0 : config.injectTimestamp) !== null && _l !== void 0 ? _l : this.injectTimestamp;
        this.shouldParseEventData =
            (_m = config === null || config === void 0 ? void 0 : config.shouldParseEventData) !== null && _m !== void 0 ? _m : this.shouldParseEventData;
        this.headers = __assign({ Authorization: "Splunk " + this.token, 'Content-Type': 'application/json' }, ((_o = config === null || config === void 0 ? void 0 : config.headers) !== null && _o !== void 0 ? _o : {}));
        var useExponentialBackoff = (_p = config === null || config === void 0 ? void 0 : config.useExponentialBackoff) !== null && _p !== void 0 ? _p : DEFAULT_USE_EXPONENTIAL_BACKOFF;
        // Exponential backoff configurations
        var exponentialBackoffLimit = config === null || config === void 0 ? void 0 : config.exponentialBackoffLimit;
        var maxNumberOfRetries = config === null || config === void 0 ? void 0 : config.maxNumberOfRetries;
        // Debounce configurations
        var debounceTime = config === null || config === void 0 ? void 0 : config.debounceTime;
        var autoRetryFlush = (_q = config === null || config === void 0 ? void 0 : config.autoRetryFlush) !== null && _q !== void 0 ? _q : true;
        if (useExponentialBackoff) {
            this.autoFlush = true;
            this.flushStrategy = new ExponentialBackoffStrategy({
                sendEvents: this.flush,
                exponentialBackoffLimit: exponentialBackoffLimit,
                maxNumberOfRetries: maxNumberOfRetries,
            });
        }
        else {
            this.flushStrategy = new DebounceStrategy({
                sendEvents: this.flush,
                debounceTime: debounceTime,
                autoRetryFlush: autoRetryFlush,
            });
        }
    };
    /**
     * Exposes the implementation for the request function
     * used to send the events to the Splunk API.
     */
    SplunkEvents.prototype.request = function (fetchContext) {
        return this._requestImpl(fetchContext);
    };
    SplunkEvents.prototype.parseEventData = function (event) {
        var parsedEvent = '';
        for (var key in event) {
            if (Object.prototype.hasOwnProperty.call(event, key) &&
                event[key] != null) {
                var value = event[key];
                switch (typeof value) {
                    case 'string':
                        parsedEvent += key + "=\"" + value.replace(/"/g, '') + "\" ";
                        break;
                    case 'boolean':
                    // eslint-disable-next-line no-fallthrough
                    case 'number':
                        parsedEvent += key + "=" + value + " ";
                        break;
                    default:
                        throw new Error('Event property must be string, number or boolean');
                }
            }
        }
        return parsedEvent;
    };
    SplunkEvents.prototype.validateEvent = function (event) {
        if (event === null) {
            throw new Error('Event must not be null');
        }
        if (event === undefined) {
            throw new Error('Event must not be undefined');
        }
        if (typeof event !== 'object') {
            throw new Error('Event must be an object');
        }
    };
    SplunkEvents.prototype.getAdditionalInfo = function () {
        if (typeof navigator === 'undefined' || typeof window === 'undefined') {
            return '';
        }
        var screen = window.screen, location = window.location;
        var additionalInfo = navigator.userAgent.replace(/,/g, ';') + "," +
            ((navigator.browserLanguage || navigator.language) + ",") +
            (navigator.platform + "," + (screen.availWidth || '-') + "," + (screen.availHeight || '-') + "," + location.hostname + ",") +
            (location.pathname + "," + location.protocol.replace(':', '') + "," + (location.hash || '-'));
        return {
            additional_info: additionalInfo,
        };
    };
    SplunkEvents.prototype.formatEventsForSplunkBatch = function (events) {
        return events.map(function (event) { return JSON.stringify(event); }).join('\n');
    };
    SplunkEvents.prototype.validateConfig = function () {
        if (this.token == null) {
            throw new Error('Token must not be null nor undefined');
        }
        if (this.endpoint == null) {
            throw new Error('Endpoint must not be null nor undefined');
        }
        if (this.flushStrategy == null) {
            throw new Error('Instance must be configured (either by constructor or calling config method) before flushing events');
        }
    };
    return SplunkEvents;
}());

module.exports = SplunkEvents;
//# sourceMappingURL=splunk-events.js.map
