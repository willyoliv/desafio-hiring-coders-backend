'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends4 = require('babel-runtime/helpers/extends');

var _extends5 = _interopRequireDefault(_extends4);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _metricLogger = require('./metricLogger');

var _metricLogger2 = _interopRequireDefault(_metricLogger);

var _v = require('uuid/v4');

var _v2 = _interopRequireDefault(_v);

var _makeApiCall = require('./makeApiCall');

var _makeApiCall2 = _interopRequireDefault(_makeApiCall);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getCurrentTime = function getCurrentTime() {
    return new Date().getTime();
};
//encapsulates the resolver with a metricLogger, witch dispatchs a begin and end event to splunk
// inject the makeApiCall function to the resolver parameters
var addLoggerToResolver = function addLoggerToResolver(splunkToken, resolver) {
    return function () {
        var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(_, args, ctx, info) {
            var metricId, start_time, response, endHandler;
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            metricId = (0, _v2.default)();
                            start_time = getCurrentTime();

                            (0, _metricLogger2.default)(metricId, ctx, 'BeginHandleRequest', {}, splunkToken, info.fieldName);
                            _context2.next = 5;
                            return resolver(_, args, ctx, info, function () {
                                var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(url, method, payload, adicionalHeaders) {
                                    return _regenerator2.default.wrap(function _callee$(_context) {
                                        while (1) {
                                            switch (_context.prev = _context.next) {
                                                case 0:
                                                    _context.next = 2;
                                                    return (0, _makeApiCall2.default)(metricId, url, ctx, method, splunkToken, info.fieldName, payload, adicionalHeaders);

                                                case 2:
                                                    return _context.abrupt('return', _context.sent);

                                                case 3:
                                                case 'end':
                                                    return _context.stop();
                                            }
                                        }
                                    }, _callee, undefined);
                                }));

                                return function (_x5, _x6, _x7, _x8) {
                                    return _ref2.apply(this, arguments);
                                };
                            }());

                        case 5:
                            response = _context2.sent;
                            endHandler = {
                                wasError: !!(!response || response.error),
                                statusCode: response && response.error ? response.error.status : 200,
                                elapsed: (getCurrentTime() - start_time).toFixed(1)
                            };

                            (0, _metricLogger2.default)(metricId, ctx, 'EndHandleRequest', endHandler, splunkToken, info.fieldName);
                            return _context2.abrupt('return', response);

                        case 9:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, undefined);
        }));

        return function (_x, _x2, _x3, _x4) {
            return _ref.apply(this, arguments);
        };
    }();
};
//map all resolvermap, including the resolvers itself and fieldResolver if exist, and invoke addLoggerToResolver
var loggerMiddleware = function loggerMiddleware(splunkToken, resolvers) {
    return Object.keys(resolvers).reduce(function (prev, rootResolverName) {
        return (0, _extends5.default)({}, prev, (0, _defineProperty3.default)({}, rootResolverName, (0, _typeof3.default)(resolvers[rootResolverName]) !== 'object' ? addLoggerToResolver(splunkToken, resolvers[rootResolverName]) : Object.keys(resolvers[rootResolverName]).reduce(function (prev, fieldResolverName) {
            return (0, _extends5.default)({}, prev, (0, _defineProperty3.default)({}, fieldResolverName, addLoggerToResolver(splunkToken, resolvers[rootResolverName][fieldResolverName])));
        }, {})));
    }, {});
};
exports.default = loggerMiddleware;