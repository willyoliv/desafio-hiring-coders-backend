'use strict';

var _typeof3 = require("babel-runtime/helpers/typeof");

var _typeof4 = _interopRequireDefault(_typeof3);

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
}

var _typeof = typeof Symbol === "function" && (0, _typeof4.default)(Symbol.iterator) === "symbol" ? function (obj) {
    return typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
} : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : (0, _typeof4.default)(obj);
};

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
            }
        }
    }return target;
};

// debounce helper
function debounce(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    if (wait == null) wait = 100;
    function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last);
        } else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    }
    var debounced = function debounced() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout) timeout = setTimeout(later, wait);
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
    debounced.clear = function () {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
    };
    return debounced;
}
// fetch helper
function fetchRequest(context) {
    if (typeof window !== 'undefined' && typeof window.fetch !== 'function' || typeof global !== 'undefined' && typeof global.fetch !== 'function') {
        console.log('Error, using fetchRequest without fetch object');
        return null;
    }
    return fetch(context.url, _extends({}, context, {
        body: context.data
    })).then(function (response) {
        if (context.responseType === 'json') {
            return response.json();
        }
        return response;
    });
}
// splunk class

var SplunkEvents = function () {
    function SplunkEvents() {
        var _this = this;

        _classCallCheck(this, SplunkEvents);

        this.logEvent = function (level, type, workflowType, workflowInstance, event, account) {
            _this.validateEvent(event);
            var parsedEvent = _this.parseEventData({
                level: level,
                type: type,
                workflowType: workflowType,
                workflowInstance: workflowInstance,
                account: account
            });
            parsedEvent += _this.parseEventData(event);
            if (_this.injectAditionalInfo) {
                parsedEvent += _this.getAdditionalInfo();
            }
            console.log('HAHAHAHAHAHAHAHAHAHA');
            var data = {
                sourcetype: _this.source,
                host: _this.host,
                time: +new Date(),
                event: parsedEvent
            };
            _this.events.push(data);
            if (_this.autoFlush) {
                _this.debouncedFlush();
            }
        };
        this.flush = function () {
            if (_this.isSendingEvents) {
                _this.debouncedFlush();
                return;
            }
            _this.validateConfig();
            _this.pendingEvents = [].concat(_this.events);
            _this.events = [];
            _this.isSendingEvents = true;
            if (_this.debug) {
                console.log('sending ' + _this.pendingEvents.length + ' events to splunk');
            }
            if (_this.pendingEvents.length === 0) {
                return;
            }
            var splunkBatchedFormattedEvents = _this.formatEventsForSplunkBatch(_this.pendingEvents);
            _this.request({
                url: '' + _this.endpoint + _this.path,
                method: 'POST',
                data: splunkBatchedFormattedEvents,
                headers: _this.headers,
                responseType: 'json'
            }).then(function (response) {
                if (_this.debug) {
                    console.log(_this.pendingEvents.length + ' events successfuly sent to splunk');
                }
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
            }).catch(function (e) {
                _this.events = _this.events.concat(_this.pendingEvents);
                _this.pendingEvents = [];
                _this.isSendingEvents = false;
                if (_this.autoRetryFlush) {
                    if (_this.debug) {
                        console.warn('Error sending events to splunk. Retrying in 5 seconds.', e);
                    }
                    _this.debouncedFlush();
                } else {
                    if (_this.debug) {
                        console.warn('Error sending events to splunk.', e);
                    }
                }
            });
        };
    }

    _createClass(SplunkEvents, [{
        key: 'config',
        value: function config(_config) {
            this.events = this.events || [];
            this.pendingEvents = this.pendingEvents || [];
            this.isSendingEvents = this.isSendingEvents || false;
            this.endpoint = _config.endpoint; // required
            this.token = _config.token; // required
            this.injectAditionalInfo = _config.injectAditionalInfo !== undefined ? _config.injectAditionalInfo : false;
            this.autoFlush = _config.autoFlush !== undefined ? _config.autoFlush : true;
            this.autoRetryFlush = _config.autoRetryFlush !== undefined ? _config.autoRetryFlush : true;
            this.source = _config.source !== undefined ? _config.source : 'log';
            this.path = _config.path !== undefined ? _config.path : '/services/collector/event';
            this.host = _config.host !== undefined ? _config.host : '-';
            this.debug = _config.debug !== undefined ? _config.debug : false;
            this.debounceTime = _config.debounceTime !== undefined ? _config.debounceTime : this.debounceTime || 2000;
            this.debouncedFlush = this.debouncedFlush || debounce(this.flush, this.debounceTime);
            this.request = _config.request !== undefined ? _config.request : this.request || fetchRequest;
            this.headers = {
                Authorization: 'Splunk ' + this.token
            };
        }
    }, {
        key: 'parseEventData',
        value: function parseEventData(event) {
            var parsedEvent = '';
            for (var key in event) {
                if (event.hasOwnProperty(key) && event[key] != null) {
                    switch (_typeof(event[key])) {
                        case 'string':
                            parsedEvent += key + '="' + event[key].replace(/\"/g, '') + '" ';
                            break;
                        case 'boolean':
                        case 'number':
                            parsedEvent += key + '=' + event[key] + ' ';
                            break;
                        default:
                            throw 'Event property must be string, number or boolean';
                    }
                }
            }
            return parsedEvent;
        }
    }, {
        key: 'validateEvent',
        value: function validateEvent(event) {
            if (event === null) {
                throw 'Event must not be null';
            }
            if (event === undefined) {
                throw 'Event must not be undefined';
            }
            if ((typeof event === 'undefined' ? 'undefined' : _typeof(event)) !== 'object') {
                throw 'Event must be an object';
            }
        }
    }, {
        key: 'getAdditionalInfo',
        value: function getAdditionalInfo() {
            if (typeof navigator === 'undefined' || typeof window === 'undefined') {
                return '';
            }
            var screen = window.screen ? window.screen : {};
            var location = window.location ? window.location : {};
            return 'additional_info="' + navigator.userAgent.replace(/\,/g, ';') + ',' + ((navigator.browserLanguage || navigator.language) + ',') + (navigator.platform + ',' + (screen.availWidth || '-') + ',' + (screen.availHeight || '-') + ',' + location.hostname + ',') + (location.pathname + ',' + location.protocol.replace(':', '') + ',' + (location.hash || '-') + '"');
        }
    }, {
        key: 'formatEventsForSplunkBatch',
        value: function formatEventsForSplunkBatch(events) {
            var splunkBatchedFormattedEvents = '';
            for (var i = 0; i < events.length; i++) {
                splunkBatchedFormattedEvents += '\n' + JSON.stringify(events[i]) + '\n';
            }
            return splunkBatchedFormattedEvents;
        }
    }, {
        key: 'validateConfig',
        value: function validateConfig() {
            if (this.token === null) {
                throw 'Token must not be null';
            }
            if (this.token === undefined) {
                throw 'Token must not be undefined';
            }
            if (this.endpoint === null) {
                throw 'endpoint must not be null';
            }
            if (this.endpoint === undefined) {
                throw 'endpoint must not be undefined';
            }
        }
    }]);

    return SplunkEvents;
}();

exports.default = SplunkEvents;