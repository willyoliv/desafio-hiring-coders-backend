"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RatesAndBenefits = void 0;
const api_1 = require("@vtex/api");
const request_1 = require("../utils/request");
const baseURL = '/api/rnb/pvt';
const csvContentType = 'text/csv';
const contentTypeHeader = 'Content-Type';
const calculatorNameHeader = 'X-VTEX-calculator-name';
const cumulativeHeader = 'X-VTEX-cumulative';
const clusterExpressionHeader = 'X-VTEX-cluster-expression';
const clusterOperatorHeader = 'X-VTEX-cluster-operator';
const startDateHeader = 'X-VTEX-start-date';
const endDateHeader = 'X-VTEX-end-date';
const defaultAuthMethod = 'ADMIN_TOKEN';
const routes = {
    getAllBenefits: `${baseURL}/benefits/calculatorconfiguration`,
    getPromotionById: (calculatorConfigurationId) => `${baseURL}/calculatorconfiguration/${calculatorConfigurationId}`,
    createOrUpdatePromotion: `${baseURL}/calculatorconfiguration`,
    createMultipleSkuPromotion: `${baseURL}/import/calculatorConfiguration`,
    updateMultipleSkuPromotion: (calculatorConfigurationId) => `${baseURL}/import/calculatorConfiguration/${calculatorConfigurationId}`,
};
class RatesAndBenefits extends api_1.JanusClient {
    constructor(ctx, options) {
        super(ctx, {
            ...options,
        });
    }
    getAllBenefits(authMethod = defaultAuthMethod, tracingConfig) {
        const metric = 'ratesAndBenefits-getAllBenefitsMetric';
        return this.http.get(routes.getAllBenefits, request_1.getRequestConfig(this.context, authMethod, metric, tracingConfig));
    }
    getPromotionById(calculatorConfigurationId, authMethod = defaultAuthMethod, tracingConfig) {
        const metric = 'ratesAndBenefits-getPromotionByIdMetric';
        return this.http.get(routes.getPromotionById(calculatorConfigurationId), request_1.getRequestConfig(this.context, authMethod, metric, tracingConfig));
    }
    createOrUpdatePromotion(calculatorConfiguration, authMethod = defaultAuthMethod, tracingConfig) {
        const metric = 'ratesAndBenefits-createOrUpdatePromotionMetric';
        return this.http.post(routes.createOrUpdatePromotion, calculatorConfiguration, request_1.getRequestConfig(this.context, authMethod, metric, tracingConfig));
    }
    createMultipleSkuPromotion(request, authMethod = defaultAuthMethod, tracingConfig) {
        const metric = 'ratesAndBenefits-createMultipleSkuPromotionMetric';
        const requestConfig = request_1.getRequestConfig(this.context, authMethod, metric, tracingConfig);
        const csv = this.mapCsvFromMultipleSkuPromotionRequest(request);
        this.setMultipleSkuPromotionHeaders(requestConfig.headers, request);
        return this.http.post(routes.createMultipleSkuPromotion, csv, requestConfig);
    }
    updateMultipleSkuPromotion(request, authMethod = defaultAuthMethod, tracingConfig) {
        const metric = 'ratesAndBenefits-updateMultipleSkuPromotionMetric';
        const requestConfig = request_1.getRequestConfig(this.context, authMethod, metric, tracingConfig);
        const csv = this.mapCsvFromMultipleSkuPromotionRequest(request);
        this.setMultipleSkuPromotionHeaders(requestConfig.headers, request);
        return this.http.put(routes.updateMultipleSkuPromotion(request.idCalculatorConfiguration), csv, requestConfig);
    }
    mapCsvFromMultipleSkuPromotionRequest(request) {
        return ['sku,effect']
            .concat(request.effects.map((v) => `${v.sku},${v.effect}`))
            .join('\n');
    }
    setMultipleSkuPromotionHeaders(headers, request) {
        headers[calculatorNameHeader] = request.calculatorName;
        headers[cumulativeHeader] = `${request.cumulative}`;
        headers[clusterExpressionHeader] = request.clusterExpression.join(', ');
        headers[clusterOperatorHeader] = request.clusterOperator;
        headers[startDateHeader] = request.startDate;
        headers[endDateHeader] = request.endDate;
        headers[contentTypeHeader] = csvContentType;
    }
}
exports.RatesAndBenefits = RatesAndBenefits;
