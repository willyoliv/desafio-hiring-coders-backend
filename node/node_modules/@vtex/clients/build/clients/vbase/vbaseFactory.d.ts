import type { InstanceOptions, IOContext, IOResponse } from '@vtex/api';
import { VBase } from '@vtex/api';
interface EntityMetadata {
    hash: string;
}
export interface EntityWithMetadata<V> {
    entity: V | null;
    metadata: EntityMetadata;
}
declare abstract class VBaseEntityRepository<V extends object> extends VBase {
    abstract save(key: string, entity: V, ifMatch?: string): Promise<void>;
    abstract trySaveIfHashMatches(key: string, hash: string, entity: V): Promise<void>;
    abstract get(key: string, nullIfNotfound?: boolean): Promise<V>;
    abstract get(key: string, nullIfNotfound: true): Promise<V | null>;
    abstract getRaw(key: string, nullIfNotfound?: boolean): Promise<IOResponse<V>>;
    abstract getWithMetadata(key: string, nullIfNotFound?: boolean): Promise<EntityWithMetadata<V>>;
}
export declare const vbaseFor: <K extends string, V extends object>(bucket: string) => new (context: IOContext, options?: InstanceOptions | undefined) => VBaseEntityRepository<V>;
export {};
